<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style type="text/css">
      body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
      }

      #chart {
        width: 100%;
        height: 100%;
        display: block;
      }

      text {
        font: 12px sans-serif;
      }
      circle {
        stroke: #565352;
        stroke-width: 1;
        fill-opacity: 0.5;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="chart"></div>

    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script>
      var width = window.innerWidth,
          height = window.innerHeight - 100, // Adjusted to accommodate the margin
          padding = 1.5,
          clusterPadding = 10,
          maxRadius = 12;

      var color = d3.scale.ordinal()
            .range(["#e60049", "#0bb4ff", "#50e991", "#e6d800", "#9b19f5", "#ffa300", "#dc0ab4", "#b3d4ff", "#00bfa0"]);

      d3.text("word_groups.csv", function(error, text) {
        if (error) throw error;
        var colNames = "text,size,group\n" + text;
        var data = d3.csv.parse(colNames);

        data.forEach(function(d) {
          d.size = +d.size;
        });

        var cs = [];
        data.forEach(function(d){
            if(!cs.includes(d.group)) {
                cs.push(d.group);
            }
        });

        var n = data.length,
            m = cs.length;

        var clusters = new Array(m);
        var nodes = [];
        for (var i = 0; i<n; i++){
            nodes.push(create_nodes(data,i));
        }

        var force = d3.layout.force()
            .nodes(nodes)
            .size([width, height])
            .gravity(0.3)
            .charge(-2000)
            .on("tick", tick)
            .start();

        var svg = d3.select("#chart").append("svg")
            .attr("width", width)
            .attr("height", height);

        var node = svg.selectAll("circle")
            .data(nodes)
            .enter().append("g").call(force.drag);

        node.append("circle")
            .style("fill", function (d) {
            return color(d.cluster);
            })
            .attr("r", function(d){return d.radius})

        node.append("text")
              .attr("dy", ".3em")
              .style("text-anchor", "middle")
              .each(function(d){
                var arr = d.text.split(" ");
                for(i = 0; i < arr.length; i+=3){
                    d3.select(this).append("tspan")
                        .text(arr.slice(i,i+3).join(" "))
                        .attr("dy", i ? "1.2em" : 0)
                        .attr("x", 0)
                        .attr("text-anchor", "middle")
                        .attr("class", "tspan" + i);
                }
            });

        function create_nodes(data,node_counter) {
          var i = cs.indexOf(data[node_counter].group),
              r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
              d = {
                cluster: i,
                radius: data[node_counter].size*1.5,
                text: data[node_counter].text,
                x: Math.cos(i / m * 2 * Math.PI) * 200 + width / 2 + Math.random(),
                y: Math.sin(i / m * 2 * Math.PI) * 200 + height / 2 + Math.random()
              };
          if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
          return d;
        };

        function tick(e) {
          node
            .each(cluster(10 * e.alpha * e.alpha))
            .each(collide(.5))
            .attr("cx", function(d) { return d.x = Math.max(d.radius, Math.min(width - d.radius, d.x)); })
            .attr("cy", function(d) { return d.y = Math.max(d.radius, Math.min(height - d.radius, d.y)); })
            .attr("transform", function (d) {
              var k = "translate(" + d.x + "," + d.y + ")";
              return k;
            });
          }


        function cluster(alpha) {
          return function (d) {
            var cluster = clusters[d.cluster];
            if (cluster === d) return;
            var x = d.x - cluster.x,
                y = d.y - cluster.y,
                l = Math.sqrt(x * x + y * y),
                r = d.radius + cluster.radius;
            if (l != r) {
              l = (l - r) / l * alpha;
              d.x -= x *= l;
              d.y -= y *= l;
              cluster.x += x;
              cluster.y += y;
            }
          };
        }

        function collide(alpha) {
          var quadtree = d3.geom.quadtree(nodes);
          return function (d) {
            var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                nx1 = d.x - r,
                nx2 = d.x + r,
                ny1 = d.y - r,
                ny2 = d.y + r;
            quadtree.visit(function (quad, x1, y1, x2, y2) {
              if (quad.point && (quad.point !== d)) {
                var x = d.x - quad.point.x,
                    y = d.y - quad.point.y,
                    l = Math.sqrt(x * x + y * y),
                    r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
                if (l < r) {
                  l = (l - r) / l * alpha;
                  d.x -= x *= l;
                  d.y -= y *= l;
                  quad.point.x += x;
                  quad.point.y += y;
                }
              }
              return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            });
          };
        }

      });
    </script>
  </body>
</html>
